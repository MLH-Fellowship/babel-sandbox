import React, { Fragment, useState } from "react";
import { parse } from "@babel/parser";
import { Grid, Menu, Accordion, Segment } from "semantic-ui-react";

/* DFS through AST generated by Babel parser */

function CompositeArr({ k, arr, cursor }) {
  const components = arr.map((value, index) => {
    return (
      <Fragment key={index}>
        {typeof value === "object" && value !== null ? (
          <Composite k={k} ast={value} cursor={cursor} />
        ) : (
          <Primitive k={k} ast={value} />
        )}
      </Fragment>
    );
  });
  const [active, setActive] = useState(false);
  const highlight =
    !active && arr.some(x => isBound(cursor, x.loc)) ? "highlight" : "";
  return arr.length ? (
    <Accordion.Accordion
      onTitleClick={() => {
        setActive(active => !active);
      }}
      panels={[
        {
          key: 0,
          title: `${k} : [ ${arr.length} element ] ${highlight}`,
          content: components,
        },
      ]}
    />
  ) : (
    <Primitive k={k} val={"[ ]"} />
  );
}

function CompositeObj({ k, obj, cursor }) {
  const components = Object.entries(obj).map(([i, v], index) => {
    return (
      <Fragment key={index}>
        {typeof v === "object" && v !== null ? (
          <Composite k={i} ast={v} cursor={cursor} />
        ) : (
          <Primitive k={i} val={v} />
        )}
      </Fragment>
    );
  });
  const { type, loc, value } = obj;
  const label = type ? type : k;
  const keys = Object.keys(obj);
  const [active, setActive] = useState(false);
  const highlight =
    (value !== undefined || !active) && isBound(cursor, loc) ? "highlight" : "";

  return keys.length ? (
    <Accordion.Accordion
      onTitleClick={() => {
        setActive(active => !active);
      }}
      panels={[
        {
          key: 0,
          title: `${label} : { ${keys.join(", ")} } ${highlight}`,
          content: components,
        },
      ]}
    />
  ) : (
    <Primitive k={label} val={"{ }"} />
  );
}

function Composite({ k, ast, cursor }) {
  return !Array.isArray(ast) ? (
    <CompositeObj k={k} obj={ast} cursor={cursor} />
  ) : (
    <CompositeArr k={k} arr={ast} cursor={cursor} />
  );
}

function Primitive({ k, val }) {
  return (
    <Accordion.Content>
      {k && k + " : "}
      {String(val)}
    </Accordion.Content>
  );
}

function Viz({ code, cursor }) {
  try {
    const ast = parse(code);
    return (
      <Segment attached="bottom">
        <Accordion
          panels={[
            { key: 0, content: <Composite k={""} ast={ast} cursor={cursor} /> },
          ]}
          fluid
          styled
        />
      </Segment>
    );
  } catch (err) {
    return <Primitive k={""} val={err.message} />;
  }
}

export default function VizOutput({ code, cursor }) {
  const cs = { line: cursor.line + 1, ch: cursor.ch + 1 };
  return (
    <Grid.Row>
      <Grid.Column>
        <Menu attached="top" tabular inverted>
          <Menu.Item>AST Explorer</Menu.Item>
        </Menu>
        <Viz code={code} cursor={cs} />
      </Grid.Column>
    </Grid.Row>
  );
}

/* 
Keyword highlighting is done by checking for the cursor position in the code 
editor and finding the nodes that contain that position. If both the start and
end values for the row or column are zero, all rows or columns are included.
If a component is toggled, that component will not be highlighted unless the
tree is at the lowest depth, indicated by a value property.
*/
function isBound(cursor, bounds) {
  if (bounds === undefined) return false;

  const { line, ch } = cursor;
  const { start, end } = bounds;

  const allRows = start.line + end.line === 0;
  const allCols = start.column + start.column === 0;

  if ((start.line > line || end.line < line) && !allRows) return false;
  if ((start.column > ch || end.column < ch) && !allCols) return false;

  return true;
}
